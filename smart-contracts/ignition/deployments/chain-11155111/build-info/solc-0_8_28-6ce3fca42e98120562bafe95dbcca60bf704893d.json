{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-6ce3fca42e98120562bafe95dbcca60bf704893d",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/facets/BrandFacet.sol": "project/contracts/facets/BrandFacet.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/facets/BrandFacet.sol": {
        "content": "// contracts/facets/BrandFacet.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.28;\r\n\r\nimport \"../libraries/Constants.sol\";\r\nimport \"../libraries/LibAppStorage.sol\";\r\nimport \"../libraries/LibProvenance.sol\";\r\nimport \"../libraries/LibAccessControl.sol\";\r\nimport \"../libraries/LibERC721.sol\";\r\n\r\nimport \"../interfaces/IProvenanceErrors.sol\";\r\nimport \"../interfaces/IProvenanceEvents.sol\";\r\n\r\nimport \"../storage/AppStorage.sol\";\r\n\r\ncontract BrandFacet is IProvenanceErrors, IProvenanceEvents {\r\n\r\n   /**\r\n    * @notice Creates (mints) a new product NFT.\r\n    * @dev Can only be called by an address with the BRAND_ROLE and an Active status.\r\n    * It creates the product's on-chain data, including its unique authenticator address,\r\n    * and mints the ERC721 token to the brand itself.\r\n    * @param _name The official name of the product being created.\r\n    * @param _productAuth The unique, product-specific address used for future signature verifications.\r\n   */\r\n   function mintProduct(\r\n      string memory _name,\r\n      address _productAuth\r\n   ) external {\r\n      if(!LibAccessControl.hasRole(Constants.BRAND_ROLE, msg.sender)){\r\n         revert AccessControlUnauthorizedAccount(msg.sender,Constants.BRAND_ROLE);\r\n      }\r\n\r\n      AppStorage storage ds = LibAppStorage.appStorage();\r\n      if (ds.brands[msg.sender].status != BrandStatus.Active) {\r\n         revert ProvenanceBrandNotActive(msg.sender, ds.brands[msg.sender].status);\r\n      }\r\n      require(_productAuth != address(0), ProvenanceZeroAddressNotAllowed());\r\n\r\n      uint256 _currentId = ds._nextTokenId;\r\n      ds._nextTokenId ++;\r\n\r\n      ds.products[_currentId] = ProductNFT({\r\n         name: _name,\r\n         brandAddress: msg.sender, \r\n         productAuthenticator: _productAuth,\r\n         mintTimestamp: block.timestamp,\r\n         saleTimestamp:0,\r\n         status: ProductStatus.InFactory\r\n      });\r\n\r\n      LibERC721.mint(msg.sender, _currentId, msg.sender);\r\n\r\n      emit ProductMinted(msg.sender, _currentId, _name, _productAuth, block.timestamp);\r\n   }\r\n\r\n\r\n   /**\r\n    * @notice Allows a brand to register a new authorized retailer.\r\n    * @dev Can only be called by an address with the BRAND_ROLE and an Active status.\r\n    * Creates a RetailerProfile, sets its status to Active, and grants it the RETAILER_ROLE.\r\n    * @param _retailerAddress The wallet address of the new retailer.\r\n    * @param _name The official name of the new retailer.\r\n   */\r\n   function registerRetailer(\r\n      address _retailerAddress, \r\n      string memory _name\r\n   ) external {\r\n      if(!LibAccessControl.hasRole(Constants.BRAND_ROLE, msg.sender)){\r\n         revert AccessControlUnauthorizedAccount(msg.sender,Constants.BRAND_ROLE);\r\n      }\r\n      AppStorage storage ds = LibAppStorage.appStorage();\r\n      if (ds.brands[msg.sender].status != BrandStatus.Active) {\r\n         revert ProvenanceBrandNotActive(msg.sender, ds.brands[msg.sender].status);\r\n      }\r\n      require(_retailerAddress != address(0), ProvenanceZeroAddressNotAllowed());\r\n      if (LibProvenance.retailerExists(_retailerAddress)) {\r\n         revert ProvenanceRetailerAlreadyExists(_retailerAddress);\r\n      }\r\n\r\n      ds.retailers[_retailerAddress] = RetailerProfile({\r\n         name: _name,\r\n         brandAddress: msg.sender,\r\n         onboardingTimestamp: block.timestamp,\r\n         status: RetailerStatus.Active\r\n      });\r\n      LibAccessControl.grantRole(Constants.RETAILER_ROLE, _retailerAddress, msg.sender);\r\n\r\n      emit RetailerRegistered(msg.sender, _retailerAddress,_name, block.timestamp);\r\n   }\r\n\r\n   /**\r\n    * @notice Allows a brand to update the status of one of its authorized retailers.\r\n    * @dev Can only be called by the brand that registered the retailer.\r\n    * If the new status is 'Terminated', the retailer's role is also permanently revoked.\r\n    * @param _retailerAddress The wallet address of the retailer to update.\r\n    * @param _newStatus The new operational status for the retailer (Active, Suspended, or Terminated).\r\n   */\r\n   function updateRetailerStatus(\r\n     address _retailerAddress, \r\n      RetailerStatus _newStatus\r\n   ) external {\r\n      if(!LibAccessControl.hasRole(Constants.BRAND_ROLE, msg.sender)){\r\n         revert AccessControlUnauthorizedAccount(msg.sender,Constants.BRAND_ROLE);\r\n      }\r\n      AppStorage storage ds = LibAppStorage.appStorage();\r\n      if (ds.brands[msg.sender].status != BrandStatus.Active) {\r\n      revert ProvenanceBrandNotActive(msg.sender, ds.brands[msg.sender].status);\r\n      }\r\n      if (!LibProvenance.retailerExists(_retailerAddress)) {\r\n         revert ProvenanceRetailerNotFound(_retailerAddress);\r\n      }\r\n\r\n      RetailerProfile memory retailer = ds.retailers[_retailerAddress];\r\n      if (retailer.brandAddress != msg.sender) {\r\n         revert ProvenanceNotAuthorizedToManageRetailer(msg.sender, _retailerAddress);\r\n      }\r\n      if (retailer.status == RetailerStatus.Terminated) {\r\n         revert ProvenanceRetailerPermanentlyTerminated(_retailerAddress);\r\n      }\r\n\r\n      ds.retailers[_retailerAddress].status = _newStatus;\r\n\r\n      if(_newStatus == RetailerStatus.Terminated){\r\n         LibAccessControl.revokeRole(Constants.RETAILER_ROLE, _retailerAddress, msg.sender);\r\n      }\r\n\r\n      emit RetailerStatusUpdated(_retailerAddress, _newStatus, block.timestamp);\r\n   }\r\n\r\n   /**\r\n    * @notice Initiates the shipment of a batch of products to a retailer.\r\n    * @dev Can only be called by an active brand. Verifies the recipient retailer is also active.\r\n    * Loops through an array of tokenIds, transfers ownership of each, and updates its status to InTransit.\r\n    * @param _tokenIds An array of token IDs to be shipped.\r\n    * @param _retailer The address of the recipient retailer.\r\n   */\r\n   function initiateShipment(\r\n      uint256[] memory _tokenIds,\r\n      address _retailer\r\n   ) external {\r\n      if(!LibAccessControl.hasRole(Constants.BRAND_ROLE, msg.sender)){\r\n         revert AccessControlUnauthorizedAccount(msg.sender,Constants.BRAND_ROLE);\r\n      }\r\n      AppStorage storage ds = LibAppStorage.appStorage();\r\n      if (ds.brands[msg.sender].status != BrandStatus.Active) {\r\n      revert ProvenanceBrandNotActive(msg.sender, ds.brands[msg.sender].status);\r\n      }\r\n      if (!LibProvenance.retailerExists( _retailer)) {\r\n         revert ProvenanceRetailerNotFound(_retailer);\r\n      }\r\n\r\n      RetailerProfile memory retailer = ds.retailers[_retailer];\r\n      if (retailer.status != RetailerStatus.Active) {\r\n         revert ProvenanceRetailerNotActive(_retailer, retailer.status);\r\n      }\r\n\r\n      for(uint256 i = 0; i < _tokenIds.length; i++){\r\n         uint256 tokenId = _tokenIds[i];\r\n         ProductStatus currentStatus = ds.products[tokenId].status;\r\n         if (currentStatus != ProductStatus.InFactory) {\r\n            revert ProvenanceInvalidProductStatus(tokenId, currentStatus, ProductStatus.InFactory);\r\n         }\r\n         LibERC721.transferFrom(msg.sender, _retailer, tokenId, msg.sender);\r\n         ds.products[tokenId].status = ProductStatus.InTransit;\r\n      }\r\n\r\n      emit ShipmentInitiated(msg.sender, _retailer, _tokenIds, block.timestamp);\r\n   }\r\n\r\n   /**\r\n    * @notice Allows a brand to confirm the receipt of a returned shipment.\r\n    * @dev Can only be called by an active brand. Updates status from InTransit back to InFactory.\r\n    * @param _tokenIds An array of token IDs that have been returned.\r\n   */\r\n   function confirmReturnReceipt(\r\n      uint256[] memory _tokenIds\r\n   ) external{\r\n      if(!LibAccessControl.hasRole(Constants.BRAND_ROLE, msg.sender)){\r\n         revert AccessControlUnauthorizedAccount(msg.sender,Constants.BRAND_ROLE);\r\n      }\r\n      AppStorage storage ds = LibAppStorage.appStorage();\r\n      for (uint256 i = 0; i < _tokenIds.length; i++) {\r\n         uint256 tokenId = _tokenIds[i];\r\n         address productOwner = LibERC721.ownerOf(tokenId);\r\n         if (productOwner != msg.sender) {\r\n            revert ProvenanceNotProductOwner(msg.sender, tokenId, productOwner);\r\n         }\r\n\r\n         ProductStatus currentStatus = ds.products[tokenId].status;\r\n         if (currentStatus != ProductStatus.InTransit) {\r\n            revert ProvenanceInvalidProductStatus(tokenId, currentStatus, ProductStatus.InTransit);\r\n         }\r\n         \r\n         ds.products[tokenId].status = ProductStatus.InFactory;\r\n      }\r\n\r\n      emit ReturnReceived(msg.sender, _tokenIds, block.timestamp);\r\n   }\r\n\r\n   \r\n   /**\r\n    * @notice Fulfills a direct-to-consumer sale, bypassing the retail channel.\r\n    * @dev Can only be called by an active brand for a product that is currently in the factory.\r\n    * Transfers ownership and updates the product's status to Sold.\r\n    * @param _tokenId The ID of the token being sold directly.\r\n    * @param _consumer The wallet address of the purchasing consumer.\r\n   */\r\n   function fulfillDirectOrder(\r\n      uint256 _tokenId,\r\n      address _consumer\r\n   ) external {\r\n      if(!LibAccessControl.hasRole(Constants.BRAND_ROLE, msg.sender)){\r\n         revert AccessControlUnauthorizedAccount(msg.sender,Constants.BRAND_ROLE);\r\n      }\r\n      AppStorage storage ds = LibAppStorage.appStorage();\r\n      if (ds.brands[msg.sender].status != BrandStatus.Active) {\r\n         revert ProvenanceBrandNotActive(msg.sender, ds.brands[msg.sender].status);\r\n      }\r\n\r\n      ProductStatus currentStatus = ds.products[_tokenId].status;\r\n      if (currentStatus != ProductStatus.InFactory) {\r\n         revert ProvenanceInvalidProductStatus(_tokenId, currentStatus, ProductStatus.InFactory);\r\n      }\r\n      \r\n      require(_consumer != address(0), ProvenanceZeroAddressNotAllowed());\r\n\r\n      LibERC721.transferFrom(msg.sender, _consumer, _tokenId, msg.sender);\r\n      ds.products[_tokenId].saleTimestamp = block.timestamp;\r\n      ds.products[_tokenId].status = ProductStatus.Sold;\r\n\r\n      emit BrandFulfilledDirectOrder(msg.sender, _consumer, _tokenId, block.timestamp);\r\n   }\r\n\r\n   /**\r\n    * @notice Retrieves the profile data for a registered retailer.\r\n    * @param _retailerAddress The address of the retailer to query.\r\n    * @return retailerProfile A RetailerProfile struct containing the retailer's data.\r\n    */\r\n   function getRetailerProfile(address _retailerAddress) external view returns (RetailerProfile memory retailerProfile) {\r\n      AppStorage storage ds = LibAppStorage.appStorage();\r\n\r\n      if (!LibProvenance.retailerExists(_retailerAddress)) {\r\n         revert ProvenanceRetailerNotFound(_retailerAddress);\r\n      }\r\n\r\n      return ds.retailers[_retailerAddress];\r\n   }\r\n\r\n   \r\n}"
      },
      "project/contracts/interfaces/IProvenanceErrors.sol": {
        "content": "// contracts/interfaces/IProvenanceErrors.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.28;\r\n\r\nimport \"../storage/AppStorage.sol\";\r\n\r\ninterface IProvenanceErrors {\r\n   // --- General Errors ---\r\n\r\n   /**\r\n    * @notice The provided address is the zero address, which is not allowed.\r\n    */\r\n   error ProvenanceZeroAddressNotAllowed();\r\n\r\n   // --- Brand Errors ---\r\n\r\n   /**\r\n    * @notice A brand with the provided address has already been registered.\r\n    * @param brandAddress The address that was submitted.\r\n   */\r\n   error ProvenanceBrandAlreadyExists(address brandAddress);\r\n\r\n   /**\r\n    * @notice No brand is registered with the provided address.\r\n    * @param brandAddress The address that was queried.\r\n   */\r\n   error ProvenanceBrandNotFound(address brandAddress);\r\n\r\n   /**\r\n    * @notice The calling brand is not in an 'Active' state and cannot perform this action.\r\n    * @param brandAddress The address of the brand attempting the action.\r\n    * @param currentStatus The brand's current, non-active status.\r\n   */\r\n   error ProvenanceBrandNotActive(address brandAddress, BrandStatus currentStatus);\r\n\r\n   /**\r\n    * @notice The specified brand has been permanently revoked and cannot be modified.\r\n    * @param brandAddress The address of the revoked brand.\r\n   */\r\n   error ProvenanceBrandPermanentlyRevoked(address brandAddress);\r\n\r\n   // --- Retailer Errors ---\r\n\r\n   /**\r\n    * @notice A retailer with the provided address has already been registered.\r\n    * @param retailerAddress The address that was submitted.\r\n   */\r\n   error ProvenanceRetailerAlreadyExists(address retailerAddress);\r\n\r\n   /**\r\n    * @notice No retailer is registered with the provided address.\r\n    * @param retailerAddress The address that was queried.\r\n   */\r\n   error ProvenanceRetailerNotFound(address retailerAddress);\r\n\r\n   /**\r\n    * @notice The target retailer is not in an 'Active' state.\r\n    * @param retailerAddress The address of the retailer.\r\n    * @param currentStatus The retailer's current, non-active status.\r\n   */\r\n   error ProvenanceRetailerNotActive(address retailerAddress, RetailerStatus currentStatus);\r\n\r\n   /**\r\n    * @notice The specified retailer has been permanently terminated and cannot be modified.\r\n    * @param retailerAddress The address of the terminated retailer.\r\n   */\r\n   error ProvenanceRetailerPermanentlyTerminated(address retailerAddress);\r\n\r\n   /**\r\n    * @notice The caller is not the brand that registered this retailer.\r\n    * @param caller The address of the unauthorized brand.\r\n    * @param retailerAddress The address of the retailer they tried to manage.\r\n   */\r\n   error ProvenanceNotAuthorizedToManageRetailer(address caller, address retailerAddress);\r\n\r\n   /**\r\n    * @notice The parent brand associated with the retailer is not in an 'Active' state.\r\n    * @param retailerAddress The address of the retailer whose parent brand is not active.\r\n    * @param brandAddress The address of the non-active parent brand.\r\n   */\r\n   error ProvenanceParentBrandNotActive(address retailerAddress, address brandAddress);\r\n\r\n   // --- Product & Verification Errors ---\r\n\r\n   /**\r\n    * @notice The provided signature is invalid as it was not created by the product's registered authenticator.\r\n    * @param tokenId The ID of the product.\r\n    * @param recoveredSigner The address that was recovered from the signature.\r\n    * @param expectedAuthenticator The address that was expected to sign.\r\n   */\r\n   error ProvenanceInvalidSignature(uint256 tokenId, address recoveredSigner, address expectedAuthenticator);\r\n\r\n   /**\r\n    * @notice The provided signature was malformed, and a signer address could not be recovered.\r\n    * @param tokenId The ID of the product for which the recovery failed.\r\n   */\r\n   error ProvenanceInvalidSignatureRecovery(uint256 tokenId);\r\n\r\n   /**\r\n    * @notice No product exists with the provided token ID.\r\n    * @param tokenId The token ID that was queried.\r\n    */\r\n   error ProvenanceProductNotFound(uint256 tokenId);\r\n\r\n   /**\r\n    * @notice The caller is not the owner of the specified product NFT.\r\n    * @param caller The address of the account that made the call.\r\n    * @param tokenId The ID of the product they attempted to access.\r\n    * @param owner The address of the actual token owner.\r\n    */\r\n   error ProvenanceNotProductOwner(address caller, uint256 tokenId, address owner);\r\n\r\n   /**\r\n    * @notice A product is not in the required state to perform an action.\r\n    * @param tokenId The ID of the product.\r\n    * @param currentStatus The product's actual current status.\r\n    * @param requiredStatus The status the product needed to be in for the action.\r\n    */\r\n   error ProvenanceInvalidProductStatus(uint256 tokenId, ProductStatus currentStatus, ProductStatus requiredStatus);\r\n\r\n   /**\r\n    * @notice The provided challenge (nonce) has already been consumed for this token.\r\n    * @param tokenId The ID of the product for which the nonce was reused.\r\n    * @param challenge The nonce that was reused.\r\n    */\r\n   error ProvenanceNonceAlreadyUsed(uint256 tokenId, uint256 challenge);\r\n\r\n   // --- ERC721 ---\r\n      \r\n   /**\r\n    * @dev Indicates a `tokenId` whose `owner` is the zero address.\r\n    * @param tokenId Identifier number of a token.\r\n    */\r\n   error ERC721NonexistentToken(uint256 tokenId);\r\n\r\n   /**\r\n    * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in ERC-20.\r\n    * Used in balance queries.\r\n    * @param owner Address of the current owner of a token.\r\n    */\r\n   error ERC721InvalidOwner(address owner);\r\n\r\n   /**\r\n    * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\r\n    * @param sender Address whose tokens are being transferred.\r\n    * @param tokenId Identifier number of a token.\r\n    * @param owner Address of the current owner of a token.\r\n    */\r\n   error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\r\n\r\n   /**\r\n    * @dev Indicates a failure with the token `sender`. Used in transfers.\r\n    * @param sender Address whose tokens are being transferred.\r\n    */\r\n   error ERC721InvalidSender(address sender);\r\n\r\n   /**\r\n    * @dev Indicates a failure with the token `receiver`. Used in transfers.\r\n    * @param receiver Address to which tokens are being transferred.\r\n    */\r\n   error ERC721InvalidReceiver(address receiver);\r\n\r\n   /**\r\n    * @dev Indicates a failure with the `operator`â€™s approval. Used in transfers.\r\n    * @param operator Address that may be allowed to operate on tokens without being their owner.\r\n    * @param tokenId Identifier number of a token.\r\n    */\r\n   error ERC721InsufficientApproval(address operator, uint256 tokenId);\r\n\r\n   /**\r\n    * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\r\n    * @param approver Address initiating an approval operation.\r\n    */\r\n   error ERC721InvalidApprover(address approver);\r\n\r\n   /**\r\n    * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\r\n    * @param operator Address that may be allowed to operate on tokens without being their owner.\r\n    */\r\n   error ERC721InvalidOperator(address operator);\r\n\r\n   //--- Access Control ---\r\n   \r\n   /**\r\n    * @dev The `account` is missing a role.\r\n    */\r\n   error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\r\n\r\n}\r\n"
      },
      "project/contracts/interfaces/IProvenanceEvents.sol": {
        "content": "// contracts/interfaces/IProvenanceEvents.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.28;\r\n\r\nimport \"../storage/AppStorage.sol\";\r\nimport \"../storage/DiamondStorage.sol\";\r\n\r\ninterface IProvenanceEvents {\r\n   /**\r\n    * @notice Emitted when a new brand is successfully registered by an admin.\r\n    * @param brandAddress The address of the newly registered brand.\r\n    * @param name The official name of the brand.\r\n    * @param timestamp The time of the registration.\r\n   */\r\n   event BrandRegistered(\r\n      address indexed brandAddress,\r\n      string name,\r\n      uint256 timestamp\r\n   );\r\n\r\n   /**\r\n    * @notice Emitted when an admin updates a brand's operational status.\r\n    * @param brandAddress The address of the brand being updated.\r\n    * @param status The new status of the brand.\r\n    * @param timestamp The time of the status update.\r\n   */\r\n   event BrandStatusUpdated(\r\n      address indexed brandAddress,\r\n      BrandStatus status,\r\n      uint256 timestamp\r\n   );\r\n\r\n   /**\r\n    * @notice Emitted when a brand successfully mints a new product NFT.\r\n    * @param brand The address of the brand that minted the product.\r\n    * @param tokenId The unique ID of the newly minted token.\r\n    * @param name The official name of the product.\r\n    * @param productAuthenticator The unique address for the product's signature verification.\r\n    * @param timestamp The time the product was minted.\r\n   */\r\n   event ProductMinted(\r\n      address indexed brand,\r\n      uint256 indexed tokenId,\r\n      string name,\r\n      address productAuthenticator,\r\n      uint256 timestamp\r\n   );\r\n\r\n   /**\r\n    * @notice Emitted when a brand registers a new retailer.\r\n    * @param brand The address of the brand registering the retailer.\r\n    * @param retailer The address of the newly registered retailer.\r\n    * @param name The name of the newly registered retailer.\r\n    * @param timestamp The time of the registration.\r\n   */\r\n   event RetailerRegistered(\r\n      address indexed brand,\r\n      address indexed retailer,\r\n      string name,\r\n      uint256 timestamp\r\n   );\r\n\r\n   /**\r\n    * @notice Emitted when a brand updates a retailer's operational status.\r\n    * @param retailer The address of the retailer being updated.\r\n    * @param status The new status of the retailer.\r\n    * @param timestamp The time of the status update.\r\n   */\r\n   event RetailerStatusUpdated(\r\n      address indexed retailer,\r\n      RetailerStatus status,\r\n      uint256 timestamp\r\n   );\r\n\r\n   /**\r\n    * @notice Emitted when a brand sells a product directly to a consumer.\r\n    * @param brand The address of the brand that sold the product.\r\n    * @param consumer The address of the consumer who purchased the product.\r\n    * @param tokenId The ID of the product that was sold.\r\n    * @param timestamp The time of the direct sale.\r\n   */\r\n   event BrandFulfilledDirectOrder(\r\n      address indexed brand,\r\n      address indexed consumer,\r\n      uint256 indexed tokenId,\r\n      uint256 timestamp\r\n   );\r\n\r\n   /**\r\n    * @notice Emitted when a brand ships a batch of products to a retailer.\r\n    * @param brand The address of the brand sending the shipment.\r\n    * @param retailer The address of the retailer receiving the shipment.\r\n    * @param tokenIds The array of product token IDs in the shipment.\r\n   */\r\n   event ShipmentInitiated(\r\n      address indexed brand,\r\n      address indexed retailer,\r\n      uint256[] tokenIds,\r\n      uint256 timestamp\r\n   );\r\n\r\n   /**\r\n    * @notice Emitted when a brand confirms the receipt of a returned shipment.\r\n    * @param brand The address of the brand that received the return.\r\n    * @param tokenIds The array of product token IDs that were returned.\r\n    * @param timestamp The time the return was confirmed.\r\n   */   \r\n   event ReturnReceived(\r\n      address indexed brand ,\r\n      uint256[] tokenIds,\r\n      uint256 timestamp\r\n   );\r\n\r\n   /**\r\n    * @notice Emitted when a retailer confirms they have received a shipment.\r\n    * @param retailer The address of the retailer that received the shipment.\r\n    * @param tokenIds The array of product token IDs that were received.\r\n    * @param timestamp The time the shipment was confirmed as received.\r\n   */\r\n   event ShipmentReceived(\r\n      address indexed retailer,\r\n      uint256[] tokenIds,\r\n      uint256 timestamp\r\n   );\r\n\r\n   /**\r\n    * @notice Emitted when a retailer initiates the return of a shipment to the brand.\r\n    * @param retailer The address of the retailer initiating the return.\r\n    * @param brand The address of the brand receiving the return.\r\n    * @param tokenIds The array of product token IDs being returned.\r\n    * @param timestamp The time the return was initiated.\r\n   */\r\n   event ShipmentReturned(\r\n      address indexed retailer,\r\n      address indexed brand,\r\n      uint256[] tokenIds,\r\n      uint256 timestamp\r\n   );\r\n\r\n   /**\r\n    * @notice Emitted when a retailer finalizes a sale to a consumer.\r\n    * @param consumer The address of the consumer who purchased the product.\r\n    * @param retailer The address of the retailer that sold the product.\r\n    * @param tokenId The ID of the product that was sold.\r\n    * @param timestamp The time of the final sale.\r\n   */\r\n   event ProductSold(\r\n      address indexed consumer,\r\n      address indexed retailer,\r\n      uint256 indexed tokenId,\r\n      uint256 timestamp\r\n   );\r\n\r\n   /**\r\n    * @notice Emitted when a product's authenticity is successfully verified on-chain.\r\n    * @dev This event signals that a specific challenge has been consumed for a tokenId.\r\n    * @param tokenId The ID of the product that was verified.\r\n    * @param challenge The unique, one-time nonce that was used for the verification.\r\n   */\r\n   event ProductVerified(\r\n      uint256 indexed tokenId, \r\n      uint256 challenge\r\n   );\r\n\r\n   // --- erc721 ---\r\n      /**\r\n    * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\r\n    */\r\n   event Transfer(\r\n      address indexed from,\r\n      address indexed to,\r\n      uint256 indexed tokenId\r\n   );\r\n\r\n   /**\r\n    * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\r\n    */\r\n   event Approval(\r\n      address indexed owner,\r\n      address indexed approved,\r\n      uint256 indexed tokenId\r\n   );\r\n\r\n   /**\r\n    * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\r\n    */\r\n   event ApprovalForAll(\r\n      address indexed owner,\r\n      address indexed operator,\r\n      bool approved\r\n   );\r\n\r\n   // --- Access Control ---\r\n   /**\r\n    * @dev Emitted when `account` is granted `role`.\r\n    *\r\n    * `sender` is the account that originated the contract call. This account bears the admin role (for the granted role).\r\n    * Expected in cases where the role was granted using the internal {AccessControl-_grantRole}.\r\n    */\r\n   event RoleGranted(\r\n      bytes32 indexed role,\r\n      address indexed account,\r\n      address indexed sender\r\n   );\r\n\r\n   /**\r\n    * @dev Emitted when `account` is revoked `role`.\r\n    *\r\n    * `sender` is the account that originated the contract call:\r\n    *   - if using `revokeRole`, it is the admin role bearer\r\n    *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\r\n    */\r\n   event RoleRevoked(\r\n      bytes32 indexed role,\r\n      address indexed account,\r\n      address indexed sender\r\n   );\r\n\r\n   /**\r\n    * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\r\n    *\r\n    * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\r\n    * {RoleAdminChanged} not being emitted to signal this.\r\n    */\r\n   event RoleAdminChanged(\r\n      bytes32 indexed role,\r\n      bytes32 indexed previousAdminRole,\r\n      bytes32 indexed newAdminRole\r\n   );\r\n\r\n   // --- Diamond ---\r\n   /**\r\n    * @dev Emitted when the Diamond's routing table is updated.\r\n    */\r\n   event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\r\n}\r\n"
      },
      "project/contracts/libraries/Constants.sol": {
        "content": "// contracts/libraries/Constants.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.28;\r\n\r\nlibrary Constants {\r\n   bytes32 constant ADMIN_ROLE = keccak256(\"ADMIN_ROLE\");\r\n   bytes32 constant BRAND_ROLE = keccak256(\"BRAND_ROLE\");\r\n   bytes32 constant RETAILER_ROLE = keccak256(\"RETAILER_ROLE\");\r\n   \r\n   //Access Control\r\n   bytes32 constant DEFAULT_ADMIN_ROLE = 0x00;\r\n}"
      },
      "project/contracts/libraries/LibAccessControl.sol": {
        "content": "// contracts/libraries/LibAccessControl.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.28;\r\n\r\nimport \"./Constants.sol\";\r\nimport \"./LibAppStorage.sol\";\r\n\r\nimport \"../storage/AppStorage.sol\";\r\n\r\nimport \"../interfaces/IProvenanceErrors.sol\";\r\nimport \"../interfaces/IProvenanceEvents.sol\";\r\n\r\n\r\nlibrary LibAccessControl {\r\n    \r\n   /**\r\n    * @notice Returns `true` if `account` has been granted `role`.\r\n    */\r\n   function hasRole(bytes32 role, address account) internal view returns (bool) {\r\n      AppStorage storage ds = LibAppStorage.appStorage();\r\n      return ds._roles[role].hasRole[account];\r\n   }\r\n\r\n\r\n    /**\r\n     * @notice Internal security check used by other library functions.\r\n     * @dev Reverts if `sender` does not have the required `role`.\r\n     * @param role The role required for the check to pass.\r\n     * @param sender The address of the original transaction sender (`msg.sender`).\r\n     */\r\n    function _checkRole(bytes32 role, address sender) internal view {\r\n        if (!hasRole(role, sender)) {\r\n            revert IProvenanceErrors.AccessControlUnauthorizedAccount(sender, role);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the admin role that controls `role`.\r\n     */\r\n    function getRoleAdmin(bytes32 role) internal view returns (bytes32) {\r\n        AppStorage storage ds = LibAppStorage.appStorage();\r\n        bytes32 adminRole = ds._roles[role].adminRole;\r\n        return adminRole == bytes32(0) ? Constants.DEFAULT_ADMIN_ROLE : adminRole;\r\n    }\r\n\r\n    /**\r\n     * @notice Grants `role` to `account`.\r\n     * @dev The `sender` must have `role`'s admin role.\r\n     * Emits a {RoleGranted} event.\r\n     * @param sender The address of the original transaction sender (`msg.sender`).\r\n     */\r\n    function grantRole(bytes32 role, address account, address sender) internal {\r\n        _checkRole(getRoleAdmin(role), sender);\r\n        AppStorage storage ds = LibAppStorage.appStorage();\r\n        if (!ds._roles[role].hasRole[account]) {\r\n            ds._roles[role].hasRole[account] = true;\r\n            emit IProvenanceEvents.RoleGranted(role, account, sender);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Revokes `role` from `account`.\r\n     * @dev The `sender` must have `role`'s admin role.\r\n     * Emits a {RoleRevoked} event.\r\n     * @param sender The address of the original transaction sender (`msg.sender`).\r\n     */\r\n    function revokeRole(bytes32 role, address account, address sender) internal {\r\n        _checkRole(getRoleAdmin(role), sender);\r\n        AppStorage storage ds = LibAppStorage.appStorage();\r\n        if (ds._roles[role].hasRole[account]) {\r\n            ds._roles[role].hasRole[account] = false;\r\n            emit IProvenanceEvents.RoleRevoked(role, account, sender);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Sets `adminRole` as ``role``'s admin role.\r\n     * @dev The `sender` must have the DEFAULT_ADMIN_ROLE.\r\n     * Emits a {RoleAdminChanged} event.\r\n     * @param sender The address of the original transaction sender (`msg.sender`).\r\n     */\r\n    function setRoleAdmin(bytes32 role, bytes32 adminRole, address sender) internal {\r\n        _checkRole(Constants.DEFAULT_ADMIN_ROLE, sender);\r\n        AppStorage storage ds = LibAppStorage.appStorage();\r\n        bytes32 previousAdminRole = getRoleAdmin(role);\r\n        ds._roles[role].adminRole = adminRole;\r\n        emit IProvenanceEvents.RoleAdminChanged(role, previousAdminRole, adminRole);\r\n    }\r\n}"
      },
      "project/contracts/libraries/LibAppStorage.sol": {
        "content": "// contracts/libraries/LibAppStorage.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.28;\r\n\r\nimport \"../storage/AppStorage.sol\";\r\n\r\nlibrary LibAppStorage {\r\n\r\n    /**\r\n     * @notice Returns a pointer to the AppStorage struct.\r\n     */\r\n    function appStorage() internal pure returns (AppStorage storage s) {\r\n        bytes32 position = keccak256(\"diamond.standard.app.storage\");\r\n        assembly {\r\n            s.slot := position\r\n        }\r\n    }\r\n}"
      },
      "project/contracts/libraries/LibERC721.sol": {
        "content": "// contracts/libraries/LibERC721.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.28;\r\n\r\nimport \"./LibAppStorage.sol\";\r\nimport \"./Constants.sol\";\r\nimport \"./LibAccessControl.sol\";\r\n\r\nimport \"../storage/AppStorage.sol\";\r\n\r\nimport \"../interfaces/IProvenanceErrors.sol\";\r\nimport \"../interfaces/IProvenanceEvents.sol\";\r\n\r\nlibrary LibERC721 {\r\n\r\n    /**\r\n     * @dev See {IERC721-balanceOf}. Returns the number of tokens owned by an account.\r\n     * @param owner The address to query the balance for.\r\n     * @return The number of tokens owned by the `owner`.\r\n     */\r\n    function balanceOf(address owner) internal view returns (uint256) {\r\n        AppStorage storage ds = LibAppStorage.appStorage();\r\n        if (owner == address(0)) {\r\n            revert IProvenanceErrors.ERC721InvalidOwner(address(0));\r\n        }\r\n        return ds._balances[owner];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-ownerOf}. Returns the owner of a given token.\r\n     * Reverts if the token does not exist.\r\n     * @param tokenId The identifier for the token to query.\r\n     * @return The address of the token's owner.\r\n     */\r\n    function ownerOf(uint256 tokenId) internal view returns (address) {\r\n        return _requireOwned(tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721Metadata-name}. Returns the name of the token collection.\r\n     */\r\n    function name() internal view returns (string memory) {\r\n        AppStorage storage ds = LibAppStorage.appStorage();\r\n        return ds._name;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721Metadata-symbol}. Returns the symbol of the token collection.\r\n     */\r\n    function symbol() internal view returns (string memory) {\r\n        AppStorage storage ds = LibAppStorage.appStorage();\r\n        return ds._symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-getApproved}. Returns the approved address for a single token.\r\n     * Reverts if the token does not exist.\r\n     * @param tokenId The identifier for the token.\r\n     * @return The approved address for the token, or the zero address if none is set.\r\n     */\r\n    function getApproved(uint256 tokenId) internal view returns (address) {\r\n        _requireOwned(tokenId);\r\n        return _getApproved(tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-isApprovedForAll}. Checks if an operator is approved by a given owner.\r\n     * @param owner The address that owns the tokens.\r\n     * @param operator The address that is the potential operator.\r\n     * @return True if the `operator` is approved to manage the `owner`'s tokens.\r\n     */\r\n    function isApprovedForAll(address owner, address operator) internal view returns (bool) {\r\n        AppStorage storage ds = LibAppStorage.appStorage();\r\n        return ds._operatorApprovals[owner][operator];\r\n    }\r\n\r\n    /**\r\n     * @dev Internal logic to transfer a token's ownership. Called by facets.\r\n     * This function ensures the sender is authorized before initiating the transfer.\r\n     * @param from The current owner of the token.\r\n     * @param to The new owner of the token.\r\n     * @param tokenId The identifier of the token to be transferred.\r\n     * @param sender The original `msg.sender` of the transaction, used for authorization.\r\n     */\r\n    function transferFrom(address from, address to, uint256 tokenId, address sender) internal {\r\n        if (to == address(0)) {\r\n            revert IProvenanceErrors.ERC721InvalidReceiver(address(0));\r\n        }\r\n        address previousOwner = _update(to, tokenId, sender);\r\n        if (previousOwner != from) {\r\n            revert IProvenanceErrors.ERC721IncorrectOwner(from, tokenId, previousOwner);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev Internal logic to create a new token and assign it to an owner.\r\n     * Enforces that the `sender` must have the `BRAND_ROLE`.\r\n     * @param to The address that will receive the newly minted token.\r\n     * @param tokenId The identifier of the new token.\r\n     * @param sender The original `msg.sender` of the transaction, used for authorization.\r\n     */\r\n    function mint(address to, uint256 tokenId, address sender) internal {\r\n        if (!LibAccessControl.hasRole(Constants.BRAND_ROLE, sender)) {\r\n            revert IProvenanceErrors.AccessControlUnauthorizedAccount(sender, Constants.BRAND_ROLE);\r\n        }\r\n\r\n        if (to == address(0)) {\r\n            revert IProvenanceErrors.ERC721InvalidReceiver(address(0));\r\n        }\r\n        address previousOwner = _update(to, tokenId, address(0)); \r\n        if (previousOwner != address(0)) {\r\n            revert IProvenanceErrors.ERC721InvalidSender(address(0));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Raw internal function to get the owner of a token. Does not revert if the token doesn't exist.\r\n     * @param tokenId The identifier of the token.\r\n     * @return The owner's address, or the zero address if the token is not minted.\r\n     */\r\n    function _ownerOf(uint256 tokenId) internal view returns (address) {\r\n        AppStorage storage ds = LibAppStorage.appStorage();\r\n        return ds._owners[tokenId];\r\n    }\r\n\r\n    /**\r\n     * @dev Raw internal function to get the approved address for a token.\r\n     * @param tokenId The identifier of the token.\r\n     * @return The approved address, or the zero address if none is set.\r\n     */\r\n    function _getApproved(uint256 tokenId) internal view returns (address) {\r\n        AppStorage storage ds = LibAppStorage.appStorage();\r\n        return ds._tokenApprovals[tokenId];\r\n    }\r\n\r\n    /**\r\n     * @dev Internal helper to check if a `spender` is authorized to manage a token.\r\n     * @param owner The owner of the token.\r\n     * @param spender The address to check for authorization.\r\n     * @param tokenId The identifier of the token.\r\n     * @return True if the spender is authorized.\r\n     */\r\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view returns (bool) {\r\n        return spender != address(0) &&\r\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal helper that reverts if a `spender` is not authorized to manage a `tokenId`.\r\n     * @param owner The owner of the token.\r\n     * @param spender The address to check for authorization.\r\n     * @param tokenId The identifier of the token.\r\n     */\r\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view {\r\n        if (!_isAuthorized(owner, spender, tokenId)) {\r\n            if (owner == address(0)) {\r\n                revert IProvenanceErrors.ERC721NonexistentToken(tokenId);\r\n            } else {\r\n                revert IProvenanceErrors.ERC721InsufficientApproval(spender, tokenId);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev The core low-level function for all token state changes (mint, transfer, burn).\r\n     * It handles balance updates, ownership changes, and clearing approvals.\r\n     * @param to The new owner of the token. Use `address(0)` for burns.\r\n     * @param tokenId The identifier of the token being updated.\r\n     * @param auth The address to check for authorization. If `address(0)`, the check is skipped.\r\n     * @return The address of the previous owner.\r\n     */\r\n    function _update(address to, uint256 tokenId, address auth) internal returns (address) {\r\n        AppStorage storage ds = LibAppStorage.appStorage();\r\n        address from = _ownerOf(tokenId);\r\n\r\n        if (auth != address(0)) {\r\n            _checkAuthorized(from, auth, tokenId);\r\n        }\r\n\r\n        if (from != address(0)) {\r\n            _approve(address(0), tokenId, address(0), false);\r\n            unchecked {\r\n                ds._balances[from] -= 1;\r\n            }\r\n        }\r\n\r\n        if (to != address(0)) {\r\n            unchecked {\r\n                ds._balances[to] += 1;\r\n            }\r\n        }\r\n\r\n        ds._owners[tokenId] = to;\r\n\r\n        emit IProvenanceEvents.Transfer(from, to, tokenId);\r\n        return from;\r\n    }\r\n\r\n    /**\r\n     * @dev Low-level internal function to set the approval for a token.\r\n     * @param to The address to approve.\r\n     * @param tokenId The identifier of the token.\r\n     * @param auth The address to check for authorization.\r\n     * @param emitEvent A boolean to indicate whether to emit an `Approval` event.\r\n     */\r\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal {\r\n        AppStorage storage ds = LibAppStorage.appStorage();\r\n        if (emitEvent || auth != address(0)) {\r\n            address owner = _requireOwned(tokenId);\r\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\r\n                revert IProvenanceErrors.ERC721InvalidApprover(auth);\r\n            }\r\n\r\n            if (emitEvent) {\r\n                emit IProvenanceEvents.Approval(owner, to, tokenId);\r\n            }\r\n        }\r\n\r\n        ds._tokenApprovals[tokenId] = to;\r\n    }\r\n\r\n    /**\r\n     * @dev Internal helper that reverts if a token does not have an owner (i.e., has not been minted).\r\n     * @param tokenId The identifier of the token to check.\r\n     * @return The address of the token's owner.\r\n     */\r\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\r\n        address owner = _ownerOf(tokenId);\r\n        if (owner == address(0)) {\r\n            revert IProvenanceErrors.ERC721NonexistentToken(tokenId);\r\n        }\r\n        return owner;\r\n    }\r\n}"
      },
      "project/contracts/libraries/LibProvenance.sol": {
        "content": "// contracts/libraries/LibProvenance.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.28;\r\n\r\nimport \"../storage/AppStorage.sol\";\r\n\r\nimport \"./LibAppStorage.sol\";\r\n\r\nimport \"../interfaces/IProvenanceErrors.sol\";\r\nimport \"../interfaces/IProvenanceEvents.sol\";\r\n\r\nlibrary LibProvenance {\r\n\r\n   /**\r\n    * @dev Checks if a brand profile has been created for a given address.\r\n    * Relies on the fact that the registrationTimestamp is only set once upon creation.\r\n   */\r\n   function brandExists(\r\n      address brandAddress\r\n   ) internal view returns (bool) {\r\n      AppStorage storage ds = LibAppStorage.appStorage();\r\n      return (ds.brands[brandAddress].registrationTimestamp != 0);\r\n   }\r\n\r\n   \r\n   /**\r\n    * @dev Checks if the parent brand of a given retailer is in an active state (not Revoked).\r\n   */\r\n   function isParentBrandActive(\r\n      address retailerAddress\r\n   ) internal view returns (bool) {\r\n      AppStorage storage ds = LibAppStorage.appStorage();\r\n      address brandAddress = ds.retailers[retailerAddress].brandAddress;\r\n      return ds.brands[brandAddress].status == BrandStatus.Active;\r\n   }\r\n   /**\r\n    * @dev Checks if a retailer profile has been created for a given address.\r\n    * Relies on the fact that the onboardingTimestamp is only set once upon creation.\r\n   */\r\n   function retailerExists(\r\n      address retailerAddress\r\n   ) internal view returns (bool) {\r\n      AppStorage storage ds = LibAppStorage.appStorage();\r\n      return (ds.retailers[retailerAddress].onboardingTimestamp != 0);\r\n   }\r\n\r\n   /**\r\n    * @dev Internal function to create the hash for a verification message.\r\n   */\r\n   function getVerificationHash(\r\n      uint256 tokenId,\r\n      uint256 challenge\r\n   ) internal pure returns (bytes32) {\r\n      return keccak256(abi.encodePacked(tokenId, challenge));\r\n   }\r\n   \r\n}"
      },
      "project/contracts/storage/AppStorage.sol": {
        "content": "// contracts/storage/AppStorage.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.28;\r\n\r\n// --- Provenance ---\r\nenum BrandStatus {Pending, Active, Suspended, Revoked}\r\nstruct BrandProfile {\r\n   address brandAddress;\r\n   string name;\r\n   string website;\r\n   uint256 registrationTimestamp;\r\n   BrandStatus status;\r\n}\r\n\r\nenum RetailerStatus {Active, Suspended, Terminated}\r\nstruct RetailerProfile {\r\n   string name;\r\n   address brandAddress;\r\n   uint256 onboardingTimestamp;\r\n   RetailerStatus status;\r\n}\r\n\r\nenum ProductStatus {InFactory, InTransit, InRetailer, Sold}\r\n\r\nstruct ProductNFT {\r\n   string name;\r\n   address brandAddress;\r\n   address productAuthenticator;\r\n   uint256 mintTimestamp;\r\n   uint256 saleTimestamp;\r\n   ProductStatus status;\r\n}\r\n\r\n//--- Access Control ---\r\nstruct RoleData {\r\n   mapping(address account => bool) hasRole;\r\n   bytes32 adminRole;\r\n}\r\n\r\nstruct AppStorage {\r\n   mapping(address => BrandProfile)  brands;\r\n   mapping(address => RetailerProfile) retailers;\r\n   mapping(uint256 => ProductNFT) products;\r\n   mapping (uint256 tokenId => mapping (uint256 nonce => bool)) isNonceUsed;\r\n\r\n   uint256 _nextTokenId;\r\n\r\n   // ERC721\r\n   string _name;\r\n   string _symbol;\r\n   mapping(uint256 => address) _owners;\r\n   mapping(address => uint256) _balances;\r\n   mapping(uint256 => address) _tokenApprovals;\r\n   mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\r\n   \r\n   //Access Control\r\n   mapping(bytes32 role => RoleData) _roles;\r\n   \r\n}\r\n"
      },
      "project/contracts/storage/DiamondStorage.sol": {
        "content": "// contracts/storage/DiamondStorage.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.28;\r\n\r\n/**\r\n * @notice Holds the state variables for the Diamond proxy mechanism.\r\n */\r\nstruct DiamondStorage {\r\n    mapping(bytes4 => address) selectorToFacetAddress;\r\n    address contractOwner;\r\n}\r\n\r\n/**\r\n * @notice The instruction set for a single facet update in a diamondCut.\r\n */\r\nstruct FacetCut {\r\n    address facetAddress;\r\n    FacetCutAction action;\r\n    bytes4[] functionSelectors;\r\n}\r\n\r\n/**\r\n * @notice The possible actions for a diamondCut.\r\n */\r\nenum FacetCutAction { Add, Replace, Remove }"
      }
    }
  }
}