{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-7ec12d07cfc1e25b9d54cc9337181b359c07150f",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/Provenance.sol": "project/contracts/Provenance.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/interfaces/IProvenanceEvents.sol": {
        "content": "// contracts/interfaces/IProvenanceEvents.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.28;\r\n\r\nimport \"../storage/AppStorage.sol\";\r\nimport \"../storage/DiamondStorage.sol\";\r\n\r\ninterface IProvenanceEvents {\r\n   /**\r\n    * @notice Emitted when a new brand is successfully registered by an admin.\r\n    * @param brandAddress The address of the newly registered brand.\r\n    * @param name The official name of the brand.\r\n    * @param timestamp The time of the registration.\r\n   */\r\n   event BrandRegistered(\r\n      address indexed brandAddress,\r\n      string name,\r\n      uint256 timestamp\r\n   );\r\n\r\n   /**\r\n    * @notice Emitted when an admin updates a brand's operational status.\r\n    * @param brandAddress The address of the brand being updated.\r\n    * @param status The new status of the brand.\r\n    * @param timestamp The time of the status update.\r\n   */\r\n   event BrandStatusUpdated(\r\n      address indexed brandAddress,\r\n      BrandStatus status,\r\n      uint256 timestamp\r\n   );\r\n\r\n   /**\r\n    * @notice Emitted when a brand successfully mints a new product NFT.\r\n    * @param brand The address of the brand that minted the product.\r\n    * @param tokenId The unique ID of the newly minted token.\r\n    * @param name The official name of the product.\r\n    * @param productAuthenticator The unique address for the product's signature verification.\r\n    * @param timestamp The time the product was minted.\r\n   */\r\n   event ProductMinted(\r\n      address indexed brand,\r\n      uint256 indexed tokenId,\r\n      string name,\r\n      address productAuthenticator,\r\n      uint256 timestamp\r\n   );\r\n\r\n   /**\r\n    * @notice Emitted when a brand registers a new retailer.\r\n    * @param brand The address of the brand registering the retailer.\r\n    * @param retailer The address of the newly registered retailer.\r\n    * @param name The name of the newly registered retailer.\r\n    * @param timestamp The time of the registration.\r\n   */\r\n   event RetailerRegistered(\r\n      address indexed brand,\r\n      address indexed retailer,\r\n      string name,\r\n      uint256 timestamp\r\n   );\r\n\r\n   /**\r\n    * @notice Emitted when a brand updates a retailer's operational status.\r\n    * @param retailer The address of the retailer being updated.\r\n    * @param status The new status of the retailer.\r\n    * @param timestamp The time of the status update.\r\n   */\r\n   event RetailerStatusUpdated(\r\n      address indexed retailer,\r\n      RetailerStatus status,\r\n      uint256 timestamp\r\n   );\r\n\r\n   /**\r\n    * @notice Emitted when a brand sells a product directly to a consumer.\r\n    * @param brand The address of the brand that sold the product.\r\n    * @param consumer The address of the consumer who purchased the product.\r\n    * @param tokenId The ID of the product that was sold.\r\n    * @param timestamp The time of the direct sale.\r\n   */\r\n   event BrandFulfilledDirectOrder(\r\n      address indexed brand,\r\n      address indexed consumer,\r\n      uint256 indexed tokenId,\r\n      uint256 timestamp\r\n   );\r\n\r\n   /**\r\n    * @notice Emitted when a brand ships a batch of products to a retailer.\r\n    * @param brand The address of the brand sending the shipment.\r\n    * @param retailer The address of the retailer receiving the shipment.\r\n    * @param tokenIds The array of product token IDs in the shipment.\r\n   */\r\n   event ShipmentInitiated(\r\n      address indexed brand,\r\n      address indexed retailer,\r\n      uint256[] tokenIds,\r\n      uint256 timestamp\r\n   );\r\n\r\n   /**\r\n    * @notice Emitted when a brand confirms the receipt of a returned shipment.\r\n    * @param brand The address of the brand that received the return.\r\n    * @param tokenIds The array of product token IDs that were returned.\r\n    * @param timestamp The time the return was confirmed.\r\n   */   \r\n   event ReturnReceived(\r\n      address indexed brand ,\r\n      uint256[] tokenIds,\r\n      uint256 timestamp\r\n   );\r\n\r\n   /**\r\n    * @notice Emitted when a retailer confirms they have received a shipment.\r\n    * @param retailer The address of the retailer that received the shipment.\r\n    * @param tokenIds The array of product token IDs that were received.\r\n    * @param timestamp The time the shipment was confirmed as received.\r\n   */\r\n   event ShipmentReceived(\r\n      address indexed retailer,\r\n      uint256[] tokenIds,\r\n      uint256 timestamp\r\n   );\r\n\r\n   /**\r\n    * @notice Emitted when a retailer initiates the return of a shipment to the brand.\r\n    * @param retailer The address of the retailer initiating the return.\r\n    * @param brand The address of the brand receiving the return.\r\n    * @param tokenIds The array of product token IDs being returned.\r\n    * @param timestamp The time the return was initiated.\r\n   */\r\n   event ShipmentReturned(\r\n      address indexed retailer,\r\n      address indexed brand,\r\n      uint256[] tokenIds,\r\n      uint256 timestamp\r\n   );\r\n\r\n   /**\r\n    * @notice Emitted when a retailer finalizes a sale to a consumer.\r\n    * @param consumer The address of the consumer who purchased the product.\r\n    * @param retailer The address of the retailer that sold the product.\r\n    * @param tokenId The ID of the product that was sold.\r\n    * @param timestamp The time of the final sale.\r\n   */\r\n   event ProductSold(\r\n      address indexed consumer,\r\n      address indexed retailer,\r\n      uint256 indexed tokenId,\r\n      uint256 timestamp\r\n   );\r\n\r\n   /**\r\n    * @notice Emitted when a product's authenticity is successfully verified on-chain.\r\n    * @dev This event signals that a specific challenge has been consumed for a tokenId.\r\n    * @param tokenId The ID of the product that was verified.\r\n    * @param challenge The unique, one-time nonce that was used for the verification.\r\n   */\r\n   event ProductVerified(\r\n      uint256 indexed tokenId, \r\n      uint256 challenge\r\n   );\r\n\r\n   // --- erc721 ---\r\n      /**\r\n    * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\r\n    */\r\n   event Transfer(\r\n      address indexed from,\r\n      address indexed to,\r\n      uint256 indexed tokenId\r\n   );\r\n\r\n   /**\r\n    * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\r\n    */\r\n   event Approval(\r\n      address indexed owner,\r\n      address indexed approved,\r\n      uint256 indexed tokenId\r\n   );\r\n\r\n   /**\r\n    * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\r\n    */\r\n   event ApprovalForAll(\r\n      address indexed owner,\r\n      address indexed operator,\r\n      bool approved\r\n   );\r\n\r\n   // --- Access Control ---\r\n   /**\r\n    * @dev Emitted when `account` is granted `role`.\r\n    *\r\n    * `sender` is the account that originated the contract call. This account bears the admin role (for the granted role).\r\n    * Expected in cases where the role was granted using the internal {AccessControl-_grantRole}.\r\n    */\r\n   event RoleGranted(\r\n      bytes32 indexed role,\r\n      address indexed account,\r\n      address indexed sender\r\n   );\r\n\r\n   /**\r\n    * @dev Emitted when `account` is revoked `role`.\r\n    *\r\n    * `sender` is the account that originated the contract call:\r\n    *   - if using `revokeRole`, it is the admin role bearer\r\n    *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\r\n    */\r\n   event RoleRevoked(\r\n      bytes32 indexed role,\r\n      address indexed account,\r\n      address indexed sender\r\n   );\r\n\r\n   /**\r\n    * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\r\n    *\r\n    * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\r\n    * {RoleAdminChanged} not being emitted to signal this.\r\n    */\r\n   event RoleAdminChanged(\r\n      bytes32 indexed role,\r\n      bytes32 indexed previousAdminRole,\r\n      bytes32 indexed newAdminRole\r\n   );\r\n\r\n   // --- Diamond ---\r\n   /**\r\n    * @dev Emitted when the Diamond's routing table is updated.\r\n    */\r\n   event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\r\n}\r\n"
      },
      "project/contracts/libraries/Constants.sol": {
        "content": "// contracts/libraries/Constants.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.28;\r\n\r\nlibrary Constants {\r\n   bytes32 constant ADMIN_ROLE = keccak256(\"ADMIN_ROLE\");\r\n   bytes32 constant BRAND_ROLE = keccak256(\"BRAND_ROLE\");\r\n   bytes32 constant RETAILER_ROLE = keccak256(\"RETAILER_ROLE\");\r\n   \r\n   //Access Control\r\n   bytes32 constant DEFAULT_ADMIN_ROLE = 0x00;\r\n}"
      },
      "project/contracts/libraries/LibAppStorage.sol": {
        "content": "// contracts/libraries/LibAppStorage.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.28;\r\n\r\nimport \"../storage/AppStorage.sol\";\r\n\r\nlibrary LibAppStorage {\r\n\r\n    /**\r\n     * @notice Returns a pointer to the AppStorage struct.\r\n     */\r\n    function appStorage() internal pure returns (AppStorage storage s) {\r\n        bytes32 position = keccak256(\"diamond.standard.app.storage\");\r\n        assembly {\r\n            s.slot := position\r\n        }\r\n    }\r\n}"
      },
      "project/contracts/libraries/LibDiamond.sol": {
        "content": "// contracts/libraries/LibDiamond.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.28;\r\n\r\nimport \"../storage/DiamondStorage.sol\";\r\nimport \"../interfaces/IProvenanceEvents.sol\";\r\n\r\nlibrary LibDiamond {\r\n\r\n   /**\r\n     * @dev Returns the storage pointer for the Diamond's internal state (owner and facet mappings).\r\n     * It uses a specific, standardized storage slot to avoid collisions with application state.\r\n     * @return ds The storage pointer for `DiamondStorage`.\r\n     */\r\n   function diamondStorage() internal pure returns (DiamondStorage storage ds) {\r\n      bytes32 position = keccak256(\"diamond.standard.diamond.storage\");\r\n      assembly {\r\n         ds.slot := position\r\n      }\r\n   }\r\n\r\n   /**\r\n     * @dev Sets the contract owner's address in the diamond's storage.\r\n     * @param _owner The address of the new contract owner.\r\n     */\r\n   function setOwner(address _owner) internal {\r\n      DiamondStorage storage ds = diamondStorage();\r\n      ds.contractOwner = _owner;\r\n   }\r\n\r\n   /**\r\n     * @dev Retrieves the current contract owner's address from diamond storage.\r\n     * @return owner_ The address of the current owner.\r\n     */\r\n   function owner() internal view returns (address owner_) {\r\n      owner_ = diamondStorage().contractOwner;\r\n   }\r\n\r\n   /**\r\n     * @dev An internal security check that reverts the transaction if `msg.sender` is not the contract owner.\r\n     * This functions as an access control modifier for owner-only functions.\r\n     */\r\n   function enforceIsOwner() internal view {\r\n      require(msg.sender == owner(), \"LibDiamond: Must be contract owner\");\r\n   }\r\n\r\n   /**\r\n     * @notice Adds, replaces, or removes functions in the Diamond.\r\n     * @dev The core logic for modifying the Diamond's function-to-facet mapping. It iterates through\r\n     * the `FacetCut` instructions and can optionally execute an initializer contract via `delegatecall`.\r\n     * @param _diamondCut An array of `FacetCut` structs detailing the upgrade actions.\r\n     * @param _init The address of a contract to call for initialization after the cut. Use address(0) if none.\r\n     * @param _calldata The function call data to send to the `_init` contract. Use empty bytes if none.\r\n     */\r\n   function diamondCut(\r\n      FacetCut[] memory _diamondCut,\r\n      address _init,\r\n      bytes memory _calldata\r\n   ) internal {\r\n      DiamondStorage storage ds = diamondStorage();\r\n      for (uint256 i = 0; i < _diamondCut.length; i++) {\r\n         FacetCutAction action = _diamondCut[i].action;\r\n         address facetAddress = _diamondCut[i].facetAddress;\r\n         bytes4[] memory selectors = _diamondCut[i].functionSelectors;\r\n\r\n         if (action == FacetCutAction.Add) {\r\n               for (uint256 j = 0; j < selectors.length; j++) {\r\n                  bytes4 selector = selectors[j];\r\n                  require(ds.selectorToFacetAddress[selector] == address(0), \"LibDiamond: Function already exists\");\r\n                  ds.selectorToFacetAddress[selector] = facetAddress;\r\n               }\r\n         } else if (action == FacetCutAction.Replace) {\r\n               for (uint256 j = 0; j < selectors.length; j++) {\r\n                  bytes4 selector = selectors[j];\r\n                  require(ds.selectorToFacetAddress[selector] != address(0), \"LibDiamond: Function does not exist\");\r\n                  ds.selectorToFacetAddress[selector] = facetAddress;\r\n               }\r\n         } else if (action == FacetCutAction.Remove) {\r\n               for (uint256 j = 0; j < selectors.length; j++) {\r\n                  bytes4 selector = selectors[j];\r\n                  require(ds.selectorToFacetAddress[selector] != address(0), \"LibDiamond: Function does not exist\");\r\n                  delete ds.selectorToFacetAddress[selector];\r\n               }\r\n         }\r\n      }\r\n      emit IProvenanceEvents.DiamondCut(_diamondCut, _init, _calldata);\r\n\r\n      if (_init != address(0)) {\r\n         (bool success, ) = _init.delegatecall(_calldata);\r\n         require(success, \"LibDiamond: DiamondInit failed\");\r\n      }\r\n   }\r\n}"
      },
      "project/contracts/Provenance.sol": {
        "content": "// contracts/Provenance.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.28;\r\n\r\nimport \"./libraries/LibDiamond.sol\";\r\nimport \"./libraries/LibAppStorage.sol\";\r\nimport \"./libraries/Constants.sol\";\r\n\r\nimport \"./storage/DiamondStorage.sol\";\r\nimport \"./storage/AppStorage.sol\";\r\n\r\ncontract Provenance {\r\n\r\n    /**\r\n     * @notice Deploys the contract, sets the owner, and performs the initial setup.\r\n     * @dev This constructor initializes all core state variables, including the contract owner, NFT metadata,\r\n     * role-based access control hierarchy, and performs the initial `diamondCut` to add all the\r\n     * essential facets to the system in a single transaction.\r\n     * @param _contractOwner The address that will have ownership over the Diamond's upgrade functionality.\r\n     * @param _diamondCut The array of `FacetCut` structs for the initial facet setup.\r\n     */\r\n    constructor(\r\n        address _contractOwner,\r\n        FacetCut[] memory _diamondCut\r\n    ) {\r\n        LibDiamond.setOwner(_contractOwner);\r\n        \r\n        AppStorage storage ds = LibAppStorage.appStorage();\r\n        \r\n        ds._name = \"Provenance Digital Twin\";\r\n        ds._symbol = \"PROV\";\r\n        ds._nextTokenId = 1;\r\n\r\n        address deployer = msg.sender; \r\n        \r\n        ds._roles[Constants.DEFAULT_ADMIN_ROLE].hasRole[deployer] = true;\r\n        ds._roles[Constants.ADMIN_ROLE].hasRole[deployer] = true;\r\n\r\n        ds._roles[Constants.ADMIN_ROLE].adminRole = Constants.DEFAULT_ADMIN_ROLE;\r\n        ds._roles[Constants.BRAND_ROLE].adminRole = Constants.ADMIN_ROLE;\r\n        ds._roles[Constants.RETAILER_ROLE].adminRole = Constants.BRAND_ROLE;\r\n\r\n        LibDiamond.diamondCut(_diamondCut, address(0), \"\");\r\n    }\r\n\r\n    /**\r\n     * @notice Explicitly rejects any direct Ether transfers to the contract.\r\n     * @dev This contract is not designed to hold a plain Ether balance. Payable functions in facets\r\n     * are still supported via the `fallback` function.\r\n     */\r\n    receive() external payable {\r\n        revert(\"This contract does not accept plain Ether transfers.\");\r\n    }\r\n    \r\n    /**\r\n     * @dev The central router for the Diamond. It is executed on every function call that does not match\r\n     * another function in this contract. It looks up the function signature in its storage to find the\r\n     * correct facet address and then uses `delegatecall` to execute the facet's code in the context\r\n     * of this contract's storage. Must be `payable` to support payable functions in facets.\r\n     */\r\n    fallback() external payable {\r\n        DiamondStorage storage ds = LibDiamond.diamondStorage();\r\n        address facetAddress = ds.selectorToFacetAddress[msg.sig];\r\n\r\n        require(facetAddress != address(0), \"Provenance: Function does not exist.\");\r\n        assembly {\r\n            calldatacopy(0, 0, calldatasize())\r\n            let result := delegatecall(gas(), facetAddress, 0, calldatasize(), 0, 0)\r\n            returndatacopy(0, 0, returndatasize())\r\n            switch result\r\n            case 0 {\r\n                revert(0, returndatasize())\r\n            }\r\n            default {\r\n                return(0, returndatasize())\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Adds, replaces, or removes functions in the Diamond.\r\n     * @dev This is the master control function for all future upgrades. It can only be called by the contract owner.\r\n     * It allows for the modification of the function-to-facet mapping and can optionally run an initializer\r\n     * function as part of an upgrade.\r\n     * @param _diamondCut An array of `FacetCut` structs detailing the upgrade actions.\r\n     * @param _init The address of a contract to call for initialization after the cut. Use address(0) if none.\r\n     * @param _calldata The function call data to send to the `_init` contract. Use empty bytes if none.\r\n     */\r\n    function diamondCut(\r\n        FacetCut[] calldata _diamondCut,\r\n        address _init,\r\n        bytes calldata _calldata\r\n    ) external {\r\n        LibDiamond.enforceIsOwner();\r\n        LibDiamond.diamondCut(_diamondCut, _init, _calldata);\r\n    }\r\n\r\n\r\n}"
      },
      "project/contracts/storage/AppStorage.sol": {
        "content": "// contracts/storage/AppStorage.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.28;\r\n\r\n// --- Provenance ---\r\nenum BrandStatus {Pending, Active, Suspended, Revoked}\r\nstruct BrandProfile {\r\n   address brandAddress;\r\n   string name;\r\n   string website;\r\n   uint256 registrationTimestamp;\r\n   BrandStatus status;\r\n}\r\n\r\nenum RetailerStatus {Active, Suspended, Terminated}\r\nstruct RetailerProfile {\r\n   string name;\r\n   address brandAddress;\r\n   uint256 onboardingTimestamp;\r\n   RetailerStatus status;\r\n}\r\n\r\nenum ProductStatus {InFactory, InTransit, InRetailer, Sold}\r\n\r\nstruct ProductNFT {\r\n   string name;\r\n   address brandAddress;\r\n   address productAuthenticator;\r\n   uint256 mintTimestamp;\r\n   uint256 saleTimestamp;\r\n   ProductStatus status;\r\n}\r\n\r\n//--- Access Control ---\r\nstruct RoleData {\r\n   mapping(address account => bool) hasRole;\r\n   bytes32 adminRole;\r\n}\r\n\r\nstruct AppStorage {\r\n   mapping(address => BrandProfile)  brands;\r\n   mapping(address => RetailerProfile) retailers;\r\n   mapping(uint256 => ProductNFT) products;\r\n   mapping (uint256 tokenId => mapping (uint256 nonce => bool)) isNonceUsed;\r\n\r\n   uint256 _nextTokenId;\r\n\r\n   // ERC721\r\n   string _name;\r\n   string _symbol;\r\n   mapping(uint256 => address) _owners;\r\n   mapping(address => uint256) _balances;\r\n   mapping(uint256 => address) _tokenApprovals;\r\n   mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\r\n   \r\n   //Access Control\r\n   mapping(bytes32 role => RoleData) _roles;\r\n   \r\n}\r\n"
      },
      "project/contracts/storage/DiamondStorage.sol": {
        "content": "// contracts/storage/DiamondStorage.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.28;\r\n\r\n/**\r\n * @notice Holds the state variables for the Diamond proxy mechanism.\r\n */\r\nstruct DiamondStorage {\r\n    mapping(bytes4 => address) selectorToFacetAddress;\r\n    address contractOwner;\r\n}\r\n\r\n/**\r\n * @notice The instruction set for a single facet update in a diamondCut.\r\n */\r\nstruct FacetCut {\r\n    address facetAddress;\r\n    FacetCutAction action;\r\n    bytes4[] functionSelectors;\r\n}\r\n\r\n/**\r\n * @notice The possible actions for a diamondCut.\r\n */\r\nenum FacetCutAction { Add, Replace, Remove }"
      }
    }
  }
}